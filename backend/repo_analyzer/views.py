import os
import subprocess
import tempfile
import py_compile
import git
from datetime import datetime
from django.conf import settings
from django.utils import timezone
from rest_framework import status
from rest_framework.decorators import api_view
from rest_framework.response import Response
from rest_framework.views import APIView
from .models import RepoTask, QueryLog
from .serializers import (
    RepoTaskSerializer, 
    QueryLogSerializer, 
    RepoTaskDetailSerializer,
    RepoSubmitSerializer
)


class SubmitRepoView(APIView):
    """Submit a repository for analysis"""
    
    def post(self, request):
        serializer = RepoSubmitSerializer(data=request.data)
        if not serializer.is_valid():
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
        
        repo_url = serializer.validated_data['repo_url']
        
        # Create RepoTask
        task = RepoTask.objects.create(
            repo_url=repo_url,
            status='pending'
        )
        
        # Start processing (synchronous for now)
        self._process_repository(task.id)
        
        return Response({
            'task_id': task.id,
            'status': 'pending',
            'message': 'Repository submitted successfully'
        }, status=status.HTTP_201_CREATED)
    
    def _process_repository(self, task_id):
        """Process the repository asynchronously"""
        try:
            task = RepoTask.objects.get(id=task_id)
            task.status = 'running'
            task.save()
            
            # Clone repository to temp directory
            repo_path = os.path.join('/tmp/repos', str(task_id))
            os.makedirs(repo_path, exist_ok=True)
            
            # Clone the repo
            repo = git.Repo.clone_from(task.repo_url, repo_path)
            
            # Run CLI tool
            result = subprocess.run(
                ['python', 'run_agent.py', '--repo', repo_path],
                capture_output=True,
                text=True,
                cwd=repo_path
            )
            
            if result.returncode == 0:
                # Check if test file was generated
                test_file_path = os.path.join(repo_path, 'tests')
                if os.path.exists(test_file_path):
                    # Validate test file
                    try:
                        py_compile.compile(test_file_path, doraise=True)
                        
                        # Create new branch
                        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
                        branch_name = f'ai-unit-tests-{timestamp}'
                        
                        # Create and switch to new branch
                        new_branch = repo.create_head(branch_name)
                        new_branch.checkout()
                        
                        # Add and commit test file
                        repo.index.add(['tests'])
                        commit = repo.index.commit(f'Add AI-generated unit tests - {timestamp}')
                        
                        # Push to remote
                        origin = repo.remote('origin')
                        origin.push(new_branch)
                        
                        # Update task
                        task.status = 'completed'
                        task.branch_name = branch_name
                        task.save()
                        
                        # Log the CLI output
                        QueryLog.objects.create(
                            task=task,
                            input_query=f"CLI tool execution for {task.repo_url}",
                            response=result.stdout,
                            status='success'
                        )
                        
                    except py_compile.PyCompileError as e:
                        task.status = 'failed'
                        task.save()
                        
                        QueryLog.objects.create(
                            task=task,
                            input_query=f"Test file validation for {task.repo_url}",
                            response=f"Validation failed: {str(e)}",
                            status='error'
                        )
                else:
                    task.status = 'failed'
                    task.save()
                    
                    QueryLog.objects.create(
                        task=task,
                        input_query=f"Test file generation for {task.repo_url}",
                        response="No test file generated by CLI tool",
                        status='error'
                    )
            else:
                task.status = 'failed'
                task.save()
                
                QueryLog.objects.create(
                    task=task,
                    input_query=f"CLI tool execution for {task.repo_url}",
                    response=f"CLI tool failed: {result.stderr}",
                    status='error'
                )
                
        except Exception as e:
            task = RepoTask.objects.get(id=task_id)
            task.status = 'failed'
            task.save()
            
            QueryLog.objects.create(
                task=task,
                input_query=f"Repository processing for {task.repo_url}",
                response=f"Processing failed: {str(e)}",
                status='error'
            )


class TaskStatusView(APIView):
    """Get task status and details"""
    
    def get(self, request, task_id):
        try:
            task = RepoTask.objects.get(id=task_id)
            serializer = RepoTaskDetailSerializer(task)
            return Response(serializer.data)
        except RepoTask.DoesNotExist:
            return Response(
                {'error': 'Task not found'}, 
                status=status.HTTP_404_NOT_FOUND
            )


class QueryHistoryView(APIView):
    """Get query history for a task"""
    
    def get(self, request, task_id):
        try:
            task = RepoTask.objects.get(id=task_id)
            query_logs = task.query_logs.all()
            serializer = QueryLogSerializer(query_logs, many=True)
            return Response(serializer.data)
        except RepoTask.DoesNotExist:
            return Response(
                {'error': 'Task not found'}, 
                status=status.HTTP_404_NOT_FOUND
            )
